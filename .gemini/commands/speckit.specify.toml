description = "자연어 기능 설명을 바탕으로 기능 사양을 생성하거나 업데이트합니다."

prompt = """
---
description: 자연어 기능 설명을 바탕으로 기능 사양을 생성하거나 업데이트합니다.
handoffs: 
  - label: 기술 계획 수립
    agent: speckit.plan
    prompt: 사양에 대한 계획을 수립합니다. 다음을 사용하여 빌드 중입니다...
  - label: 사양 요구 사항 명확화
    agent: speckit.clarify
    prompt: 사양 요구 사항을 명확히 합니다.
    send: true
---

## 사용자 입력

```text
$ARGUMENTS
```

진행하기 전에 사용자 입력이 비어 있지 않다면 이를 **반드시** 고려해야 합니다.

## 개요

트리거 메시지에서 `/speckit.specify` 뒤에 사용자가 입력한 텍스트가 **기능 설명**입니다. `{{args}}`가 아래에 문자 그대로 나타나더라도 이 대화에서 항상 사용할 수 있다고 가정하십시오. 명령이 비어 있지 않는 한 사용자에게 반복을 요청하지 마십시오.

해당 기능 설명이 주어지면 다음을 수행하십시오:

1. **간결한 짧은 이름** (2-4단어)을 브랜치용으로 생성합니다:
   - 기능 설명을 분석하여 가장 의미 있는 키워드를 추출합니다.
   - 기능의 핵심을 포착하는 2-4단어의 짧은 이름을 만듭니다.
   - 가능하면 '동사-명사' 형식을 사용합니다 (예: "add-user-auth", "fix-payment-bug").
   - 기술 용어 및 약어(OAuth2, API, JWT 등)를 보존합니다.
   - 간결하면서도 한눈에 기능을 이해할 수 있을 만큼 설명적이어야 합니다.
   - 예시:
     - "사용자 인증을 추가하고 싶습니다" → "user-auth"
     - "API를 위한 OAuth2 통합 구현" → "oauth2-api-integration"
     - "분석을 위한 대시보드 생성" → "analytics-dashboard"
     - "결제 처리 타임아웃 버그 수정" → "fix-payment-timeout"

2. **새 브랜치를 생성하기 전에 기존 브랜치를 확인합니다**:

   a. 먼저, 최신 정보를 확보하기 위해 모든 원격 브랜치를 가져옵니다:

      ```bash
      git fetch --all --prune
      ```

   b. 짧은 이름(short-name)에 대해 모든 소스에서 가장 높은 기능 번호를 찾습니다:
      - 원격 브랜치: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 로컬 브랜치: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 사양 디렉토리: `specs/[0-9]+-<short-name>`과 일치하는 디렉토리 확인

   c. 다음 사용 가능한 번호를 결정합니다:
      - 세 가지 소스 모두에서 모든 번호를 추출합니다.
      - 가장 높은 번호 N을 찾습니다.
      - 새 브랜치 번호로 N+1을 사용합니다.

   d. 계산된 번호와 짧은 이름을 사용하여 다음 스크립트를 실행합니다:
      - **Windows**: `.specify/scripts/powershell/create-new-feature.ps1 --json "{{args}}" --number N+1 --short-name "your-short-name" "Add user authentication"`
      - **그 외**: `.specify/scripts/bash/create-new-feature.sh --json "{{args}}" --number N+1 --short-name "your-short-name" "Add user authentication"`
      - 인자로 N+1 번호, "your-short-name", 그리고 기능 설명을 함께 전달하십시오.
      - "I'm Groot"와 같이 인자에 작은따옴표가 포함된 경우 이스케이프 구문을 사용하십시오: 예: 'I'\\''m Groot' (또는 가능하면 큰따옴표: "I'm Groot").

   **중요**:
   - 원격 브랜치, 로컬 브랜치, 사양 디렉토리 세 곳을 모두 확인하여 가장 높은 번호를 찾으십시오.
   - 정확한 short-name 패턴과 일치하는 브랜치/디렉토리만 일치시키십시오.
   - 이 short-name으로 된 기존 브랜치/디렉토리가 없으면 1번부터 시작하십시오.
   - 이 스크립트는 기능당 한 번만 실행해야 합니다.
   - 터미널에 출력으로 제공되는 JSON을 항상 참조하여 찾고 있는 실제 내용을 확인하십시오.
   - JSON 출력에는 BRANCH_NAME 및 SPEC_FILE 경로가 포함됩니다.

3. 필요한 섹션을 이해하기 위해 `.specify/templates/spec-template.md`를 로드합니다.

4. 다음 실행 흐름을 따르십시오:

    1. 입력에서 사용자 설명을 파싱합니다.
       비어 있는 경우: ERROR "기능 설명이 제공되지 않았습니다"
    2. 설명에서 핵심 개념을 추출합니다.
       행위자(actors), 액션(actions), 데이터(data), 제약 사항(constraints)을 식별합니다.
    3. 불명확한 측면에 대해:
       - 컨텍스트와 업계 표준을 바탕으로 정보에 입각한 추측을 합니다.
       - 다음의 경우에만 `[확인 필요(NEEDS CLARIFICATION): 구체적인 질문]`으로 표시합니다:
         - 선택이 기능 범위나 사용자 경험에 중대한 영향을 미치는 경우
         - 서로 다른 함의를 가진 여러 합리적인 해석이 존재하는 경우
         - 합리적인 기본값이 존재하지 않는 경우
       - **제한: 총 [확인 필요] 마커는 최대 3개까지만 사용 가능**
       - 우선순위에 따라 명확화 사항을 정리하십시오: 범위 > 보안/개인정보 보호 > 사용자 경험 > 기술적 세부 사항
    4. 사용자 시나리오 및 테스트 섹션을 작성합니다.
       명확한 사용자 흐름이 없는 경우: ERROR "사용자 시나리오를 결정할 수 없습니다"
    5. 기능 요구 사항을 생성합니다.
       각 요구 사항은 테스트 가능해야 합니다.
       지정되지 않은 세부 사항에 대해서는 합리적인 기본값을 사용하십시오(가정(Assumptions) 섹션에 기록).
    6. 성공 기준을 정의합니다.
       측정 가능하고 기술 중립적인 결과를 만듭니다.
       정량적 지표(시간, 성능, 볼륨)와 정성적 측정(사용자 만족도, 작업 완료)을 모두 포함하십시오.
       각 기준은 구현 세부 사항 없이 검증 가능해야 합니다.
    7. 주요 엔티티를 식별합니다 (데이터가 포함된 경우).
    8. 반환: 성공 (SUCCESS, 사양 계획 준비 완료)

5. 템플릿 구조를 사용하여 사양을 SPEC_FILE에 기록하고, 섹션 순서와 헤딩을 유지하면서 자리 표시자를 기능 설명(인자)에서 도출된 구체적인 세부 사항으로 바꿉니다.

6. **사양 품질 검증**: 초기 사양을 작성한 후 품질 기준에 따라 검증합니다:

   a. **사양 품질 체크리스트 생성**: 계획 단계로 넘어가기 전에 `FEATURE_DIR/checklists/requirements.md`에 다음 검증 항목을 포함한 체크리스트 파일을 생성합니다:

      ```markdown
      # 사양 품질 체크리스트: [기능 이름]
      
      **목적**: 계획 단계로 진행하기 전에 기능 사양의 완전성과 품질을 검증합니다.
      **생성일**: [날짜]
      **기능**: [spec.md 링크]
      
      ## 콘텐츠 품질
      
      - [ ] 구현 세부 사항(언어, 프레임워크, API)이 없음
      - [ ] 사용자 가치와 비즈니스 요구 사항에 집중함
      - [ ] 비기술적 이해관계자를 위해 작성됨
      - [ ] 모든 필수 섹션이 완료됨
      
      ## 요구 사항 완전성
      
      - [ ] [확인 필요] 마커가 남아 있지 않음
      - [ ] 요구 사항이 테스트 가능하고 모호하지 않음
      - [ ] 성공 기준이 측정 가능함
      - [ ] 성공 기준이 기술 중립적임 (구현 세부 사항 없음)
      - [ ] 모든 수락 시나리오가 정의됨
      - [ ] 예외 케이스가 식별됨
      - [ ] 범위가 명확하게 경계 지어짐
      - [ ] 의존성 및 가정이 식별됨
      
      ## 기능 준비 상태
      
      - [ ] 모든 기능적 요구 사항에 명확한 수락 기준이 있음
      - [ ] 사용자 시나리오가 주요 흐름을 포괄함
      - [ ] 기능이 성공 기준에서 정의된 측정 가능한 결과를 충족함
      - [ ] 사양에 구현 세부 사항이 유출되지 않음
      
      ## 참고 사항
      
      - 미완료로 표시된 항목은 `/speckit.clarify` 또는 `/speckit.plan` 전에 사양 업데이트가 필요함
      ```

   b. **검증 체크 실행**: 각 체크리스트 항목에 대해 사양을 검토합니다:
      - 각 항목의 통과 또는 실패 여부를 결정합니다.
      - 발견된 구체적인 문제(관련 사양 섹션 인용)를 문서화합니다.

   c. **검증 결과 처리**:

      - **모든 항목이 통과하는 경우**: 체크리스트를 완료로 표시하고 6단계로 진행합니다.

      - **항목이 실패하는 경우 ([확인 필요] 제외)**:
        1. 실패한 항목과 구체적인 문제를 나열합니다.
        2. 각 문제를 해결하기 위해 사양을 업데이트합니다.
        3. 모든 항목이 통과할 때까지 검증을 다시 실행합니다 (최대 3회 반복).
        4. 3회 반복 후에도 여전히 실패하면 남은 문제를 체크리스트 참고 사항에 기록하고 사용자에게 경고합니다.

      - **[확인 필요] 마커가 남은 경우**:
        1. 사양에서 모든 `[확인 필요: ...]` 마커를 추출합니다.
        2. **제한 확인**: 마커가 3개를 초과하는 경우 가장 중요한 3개(범위/보안/UX 영향 기준)만 유지하고 나머지는 합리적으로 추측합니다.
        3. 각 명확화가 필요한 사항(최대 3개)에 대해 다음 형식으로 사용자에게 옵션을 제시합니다:

           ```markdown
           ## 질문 [N]: [주제]
           
           **컨텍스트**: [관련 사양 섹션 인용]
           
           **확인이 필요한 사항**: [확인 필요 마커의 구체적인 질문]
           
           **권장 답변**:
           
           | 옵션 | 답변 | 영향 |
           |------|------|------|
           | A    | [첫 번째 권장 답변] | [이것이 기능에 의미하는 바] |
           | B    | [두 번째 권장 답변] | [이것이 기능에 의미하는 바] |
           | C    | [세 번째 권장 답변] | [이것이 기능에 의미하는 바] |
           | 직접 입력 | 직접 답변 제공 | [직접 입력 방법을 설명] |
           
           **선택**: _[사용자 응답 대기]_
           ```

        4. **중요 - 표 서식**: 마크다운 표가 올바르게 서식화되었는지 확인하십시오:
           - 파이프(|)가 정렬되도록 일관된 간격을 사용하십시오.
           - 각 셀은 내용 주위에 공백이 있어야 합니다: `|내용|`이 아닌 `| 내용 |`.
           - 헤더 구분선은 최소 3개의 대시를 가져야 합니다: `|---|`.
           - 마크다운 미리보기에서 표가 올바르게 렌더링되는지 확인하십시오.
        5. 질문에 순차적으로 번호를 매기십시오 (Q1, Q2, Q3 - 총 최대 3개).
        6. 응답을 기다리기 전에 모든 질문을 함께 제시하십시오.
        7. 사용자가 모든 질문에 대한 선택을 완료할 때까지 기다리십시오 (예: "Q1: A, Q2: 직접 입력 - [내용], Q3: B").
        8. 각 [확인 필요] 마커를 사용자가 선택하거나 제공한 답변으로 교체하여 사양을 업데이트합니다.
        9. 모든 명확화 사항이 해결된 후 검증을 다시 실행합니다.

   d. **체크리스트 업데이트**: 각 검증 반복 후 현재 통과/실패 상태로 체크리스트 파일을 업데이트합니다.

7. 브랜치 이름, 사양 파일 경로, 체크리스트 결과 및 다음 단계(`/speckit.clarify` 또는 `/speckit.plan`)에 대한 준비 상태를 보고합니다.

**참고:** 스크립트는 새 브랜치를 생성 및 체크아웃하고 작성 전에 사양 파일을 초기화합니다.

## 일반 가이드라인

- 사용자가 무엇을(**WHAT**) 필요로 하고 왜(**WHY**) 필요한지에 집중하십시오.
- 구현 방법(**HOW**)은 피하십시오 (기술 스택, API, 코드 구조 없음).
- 개발자가 아닌 비즈니스 이해관계자를 위해 작성하십시오.
- 사양에 내장된 체크리스트를 생성하지 마십시오. 그것은 별도의 명령이 될 것입니다.

### 섹션 요구 사항

- **필수 섹션**: 모든 기능에 대해 작성해야 합니다.
- **선택 섹션**: 기능과 관련이 있는 경우에만 포함하십시오.
- 섹션이 해당되지 않는 경우 완전히 제거하십시오 ("해당 없음"으로 남겨두지 마십시오).

### AI 생성 시 참고 사항

사용자 프롬프트에서 이 사양을 생성할 때:
1. **정보에 입각한 추측**: 컨텍스트, 업계 표준 및 공통 패턴을 사용하여 공백을 채웁니다.
2. **가정 문서화**: 합리적인 기본값을 가정(Assumptions) 섹션에 기록합니다.
3. **명확화 제한**: [확인 필요] 마커는 최대 3개로 제한합니다. 다음의 중요한 결정 사항에만 사용하십시오:
   - 기능 범위나 사용자 경험에 중대한 영향을 미침
   - 서로 다른 함의를 가진 여러 해석이 가능함
   - 합리적인 기본값이 없음
4. **명확화 우선순위**: 범위 > 보안/개인정보 보호 > 사용자 경험 > 기술적 세부 사항
5. **테스터처럼 생각하기**: 모호한 요구 사항은 "테스트 가능하고 모호하지 않음" 체크리스트 항목에서 실패해야 합니다.
6. **명확화가 필요한 일반적인 영역** (합리적인 기본값이 없는 경우에만):
   - 기능 범위 및 경계 (특정 유스케이스 포함/제외)
   - 사용자 유형 및 권한 (상충하는 해석이 가능한 경우)
   - 보안/규정 준수 요구 사항 (법적/재정적으로 중요한 경우)

**합리적인 기본값의 예** (질문하지 마십시오):
- 데이터 보관: 도메인에 대한 업계 표준 관행
- 성능 목표: 특별히 지정되지 않은 경우 표준 웹/모바일 앱 기대치
- 에러 처리: 적절한 폴백이 있는 사용자 친화적인 메시지
- 인증 방법: 웹 앱의 경우 표준 세션 기반 또는 OAuth2
- 통합 패턴: 별도로 명시되지 않은 경우 RESTful API

### 성공 기준 가이드라인

성공 기준은 반드시 다음과 같아야 합니다:
1. **측정 가능**: 특정 지표(시간, 백분율, 횟수, 비율)를 포함합니다.
2. **기술 중립적**: 프레임워크, 언어, 데이터베이스 또는 도구에 대한 언급이 없어야 합니다.
3. **사용자 중심**: 시스템 내부가 아닌 사용자/비즈니스 관점의 결과를 설명합니다.
4. **검증 가능**: 구현 세부 사항을 모르더라도 테스트/검증할 수 있습니다.

**좋은 예**:
- "사용자가 3분 이내에 결제를 완료할 수 있음"
- "시스템이 10,000명의 동시 사용자를 지원함"
- "검색의 95%가 1초 이내에 결과를 반환함"
- "작업 완료율이 40% 향상됨"

**나쁜 예** (구현 중심):
- "API 응답 시간이 200ms 미만임" (너무 기술적임, "사용자가 즉시 결과를 확인" 사용)
- "데이터베이스가 1000 TPS를 처리할 수 있음" (구현 세부 사항, 사용자 대상 지표 사용)
- "React 컴포넌트가 효율적으로 렌더링됨" (프레임워크 특정적임)
- "Redis 캐시 적중률이 80% 이상임" (기술 특정적임)
"""
