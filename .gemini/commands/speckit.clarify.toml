description = "최대 5개의 고도로 타겟팅된 명확화 질문을 던지고 답변을 사양에 다시 인코딩하여 현재 기능 사양에서 미비한 영역을 식별합니다."

prompt = """
---
description: 최대 5개의 고도로 타겟팅된 명확화 질문을 던지고 답변을 사양에 다시 인코딩하여 현재 기능 사양에서 미비한 영역을 식별합니다.
handoffs: 
  - label: 기술 계획 수립
    agent: speckit.plan
    prompt: 사양에 대한 계획을 수립합니다. 다음을 사용하여 빌드 중입니다...
---

## 사용자 입력

```text
$ARGUMENTS
```

진행하기 전에 사용자 입력이 비어 있지 않다면 이를 **반드시** 고려해야 합니다.

## 개요

목표: 활성 기능 사양에서 모호성 또는 누락된 결정 지점을 감지하고 줄이며, 명확해진 내용을 사양 파일에 직접 기록합니다.

참고: 이 명확화 워크플로우는 `/speckit.plan`을 호출하기 전에 실행(및 완료)되어야 합니다. 사용자가 명시적으로 명확화 단계를 건너뛴다고 언급하는 경우(예: 탐색적 스파이크), 진행할 수 있으나 이후 재작업 위험이 높아진다는 점을 경고해야 합니다.

실행 단계:

1. 저장소 루트에서 다음 스크립트를 **한 번** 실행합니다. JSON 페이로드 필드를 구문 분석합니다.
   - **Windows**: `.specify/scripts/powershell/check-prerequisites.ps1 --json --paths-only`
   - **그 외**: `.specify/scripts/bash/check-prerequisites.sh --json --paths-only`
   - 구문 분석할 필드: `FEATURE_DIR`, `FEATURE_SPEC` (추후 체인 흐름을 위해 `IMPL_PLAN`, `TASKS`도 캡처 가능)
   - JSON 파싱 실패 시 중단하고 사용자에게 `/speckit.specify`를 다시 실행하거나 기능 브랜치 환경을 확인하도록 안내하십시오.
   - "I'm Groot"와 같이 인자에 작은따옴표가 포함된 경우 이스케이프 구문을 사용하십시오: 예: 'I'\\''m Groot' (또는 가능하면 큰따옴표: "I'm Groot").

2. 현재 사양 파일을 로드합니다. 다음 분류를 사용하여 구조화된 모호성 및 커버리지 스캔을 수행합니다. 각 카테고리에 대해 상태를 표시합니다: 명확(Clear) / 부분적(Partial) / 누락(Missing). 우선순위 지정을 위해 사용되는 내부 커버리지 맵을 생성합니다 (질문을 하지 않을 경우가 아니라면 원본 맵을 출력하지 마십시오).

   기능적 범위 및 동작:
   - 핵심 사용자 목표 및 성공 기준
   - 명시적인 범위 외(Out-of-scope) 선언
   - 사용자 역할 / 페르소나 차별화

   도메인 및 데이터 모델:
   - 엔티티, 속성, 관계
   - ID 및 고유성 규칙
   - 수명 주기/상태 전환
   - 데이터 볼륨 / 규모 가정

   상호작용 및 UX 흐름:
   - 핵심 사용자 여정 / 시퀀스
   - 에러/빈 화면/로딩 상태
   - 접근성 또는 현지화 메모

   비기능적 품질 속성:
   - 성능 (지연 시간, 처리량 목표)
   - 확장성 (수평/수직, 제한)
   - 신뢰성 및 가용성 (가동 시간, 복구 기대치)
   - 관측 가능성 (로깅, 지표, 트레이싱 신호)
   - 보안 및 개인정보 보호 (인증/인가, 데이터 보호, 위협 가정)
   - 규정 준수 / 규제 제약 (있는 경우)

   통합 및 외부 의존성:
   - 외부 서비스/API 및 실패 모드
   - 데이터 가져오기/내보내기 형식
   - 프로토콜/버전 관리 가정

   예외 케이스 및 실패 처리:
   - 부정적 시나리오
   - 속도 제한 / 스로틀링
   - 충돌 해결 (예: 동시 편집)

   제약 사항 및 트레이드오프:
   - 기술적 제약 (언어, 저장소, 호스팅)
   - 명시적인 트레이드오프 또는 거부된 대안

   용어 및 일관성:
   - 표준 용어집 용어
   - 기피하는 동의어 / 지원 중단된 용어

   완료 신호:
   - 수락 기준 테스트 가능성
   - 측정 가능한 완료 정의(Definition of Done) 스타일 지표

   기타 / 자리 표시자:
   - TODO 마커 / 미해결 결정 사항
   - 정량화가 부족한 모호한 형용사 ("견고한", "직관적인")

   부분적(Partial) 또는 누락(Missing) 상태인 각 카테고리에 대해 후보 질문 기회를 추가합니다. 단, 다음의 경우는 제외합니다:
   - 명확화가 구현이나 검증 전략을 실질적으로 바꾸지 않는 경우
   - 정보가 계획 단계로 미루는 것이 더 나은 경우 (내부적으로 기록)

3. 후보 명확화 질문의 우선순위 큐를 생성합니다 (최대 5개). 한꺼번에 출력하지 마십시오. 다음 제약 사항을 적용합니다:
    - 전체 세션 동안 총 질문 수는 최대 10개입니다.
    - 각 질문은 반드시 다음 중 하나로 답변 가능해야 합니다:
       - 짧은 객관식 선택 (2–5개의 고유하고 상호 배제적인 옵션)
       - 단어 하나 / 짧은 구문 답변 (명시적으로 제한: "5단어 이내로 답변해 주세요")
    - 아키텍처, 데이터 모델링, 작업 분해, 테스트 설계, UX 동작, 운영 준비 또는 규정 준수 검증에 실질적인 영향을 미치는 질문만 포함하십시오.
    - 카테고리 커버리지 균형 보장: 해결되지 않은 가장 영향력 있는 카테고리를 먼저 다루려고 노력하십시오. 보안 태세와 같은 고영향 영역이 해결되지 않았는데 저영향 질문 두 개를 묻지 마십시오.
    - 이미 답변된 질문, 사소한 스타일 선호도 또는 계획 수준의 실행 세부 사항(정확성을 방해하지 않는 한)은 제외하십시오.
    - 다운스트림 재작업 위험을 줄이거나 잘못 정렬된 수락 테스트를 방지하는 명확화를 선호하십시오.
    - 5개 이상의 카테고리가 해결되지 않은 경우 (영향도 * 불확실성) 휴리스틱에 따라 상위 5개를 선택하십시오.

4. 순차적 질문 루프 (대화형):
    - **한 번에 정확히 하나의 질문**만 제시합니다.
    - 객관식 질문의 경우:
       - **모든 옵션을 분석**하고 다음을 기준으로 **가장 적합한 옵션**을 결정합니다:
          - 프로젝트 유형에 대한 모범 사례
          - 유사한 구현에서의 공통 패턴
          - 위험 감소 (보안, 성능, 유지보수성)
          - 사양에 나타난 명시적인 프로젝트 목표 또는 제약 사항과의 정렬
       - 명확한 근거(이것이 왜 최선의 선택인지 설명하는 1-2문장)와 함께 **권장 옵션을 맨 위에 눈에 띄게** 제시하십시오.
       - 형식: `**권장 사항:** 옵션 [X] - <이유>`
       - 그런 다음 모든 옵션을 마크다운 표로 렌더링합니다:

       | 옵션 | 설명 |
       |------|------|
       | A | <옵션 A 설명> |
       | B | <옵션 B 설명> |
       | C | <옵션 C 설명> (필요에 따라 D/E 추가, 최대 5개) |
       | 기타 | 다른 짧은 답변 제공 (5단어 이내) (자유 형식 대안이 적절한 경우에만 포함) |

       - 표 뒤에 다음을 추가합니다: `옵션 문자(예: "A")로 답하거나, "네" 또는 "권장"이라고 말하여 권장 사항을 수락하거나, 직접 짧은 답변을 제공할 수 있습니다.`
    - 단답형 스타일 (의미 있는 개별 옵션이 없는 경우):
       - 모범 사례와 컨텍스트를 기반으로 **제안된 답변**을 제공합니다.
       - 형식: `**제안:** <제안하는 답변> - <간략한 이유>`
       - 그런 다음 출력: `형식: 짧은 답변 (5단어 이내). "네" 또는 "제안"이라고 말하여 제안을 수락하거나 직접 답변을 제공할 수 있습니다.`
    - 사용자가 답변한 후:
       - 사용자가 "네", "권장" 또는 "제안"으로 답하면 이전에 언급한 권장/제안 사항을 답변으로 사용합니다.
       - 그렇지 않은 경우, 답변이 하나의 옵션에 매핑되거나 5단어 이내 제약에 맞는지 검증합니다.
       - 모호한 경우 빠른 명확화를 요청하십시오 (이때 질문 횟수는 증가하지 않으며 다음으로 넘어가지 않습니다).
       - 만족스러우면 작업 메모리에 기록하고(아직 디스크에 쓰지 않음) 다음 대기 중인 질문으로 이동합니다.
    - 다음의 경우 질문을 중단합니다:
       - 모든 중요한 모호성이 일찍 해결된 경우 (남은 큐 항목이 불필요해짐)
       - 사용자가 완료 신호를 보낸 경우 ("완료", "좋음", "그만")
       - 질문 횟수가 5개에 도달한 경우
    - 미래의 대기 중인 질문을 미리 공개하지 마십시오.
    - 시작 시 유효한 질문이 존재하지 않으면 즉시 중요한 모호성이 없음을 보고하십시오.

5. 각 수락된 답변 후 통합 (증분 업데이트 방식):
    - 로드된 사양의 메모리 내 표현과 원본 파일 내용을 유지합니다.
    - 이 세션의 첫 번째 통합 답변에 대해:
       - `## Clarifications` 섹션이 존재하는지 확인합니다 (누락된 경우 사양 템플릿에 따라 가장 높은 수준의 컨텍스트/개요 섹션 바로 뒤에 생성).
       - 그 아래에 오늘 날짜에 대한 `### Session YYYY-MM-DD` 부제목을 생성합니다 (없는 경우).
    - 수락 직후 불렛 라인을 추가합니다: `- Q: <질문> → A: <최종 답변>`.
    - 그런 다음 즉시 가장 적절한 섹션에 명확화 내용을 적용합니다:
       - 기능적 모호성 → 기능 요구 사항(Functional Requirements)의 불렛을 업데이트하거나 추가합니다.
       - 사용자 상호작용 / 행위자 구분 → 명확해진 역할, 제약 또는 시나리오로 사용자 스토리(User Stories) 또는 행위자(Actors) 하위 섹션을 업데이트합니다.
       - 데이터 형태 / 엔티티 → 순서를 유지하면서 데이터 모델(Data Model)을 업데이트합니다 (필드, 유형, 관계 추가). 추가된 제약 사항을 간결하게 기록합니다.
       - 비기능적 제약 → 비기능 / 품질 속성 섹션에 측정 가능한 기준을 추가/수정합니다 (모호한 형용사를 지표나 명시적 목표로 변환).
       - 예외 케이스 / 부정적 흐름 → 예외 케이스 / 에러 처리(Edge Cases / Error Handling) 아래에 새로운 불렛을 추가합니다.
       - 용어 충돌 → 사양 전반에서 용어를 표준화합니다. 필요한 경우에만 `(이전에는 "X"로 지칭됨)`을 한 번 추가하여 원래 용어를 유지합니다.
    - 명확화 내용이 이전의 모호한 진술을 무효화하는 경우, 중복하지 말고 해당 진술을 대체하십시오. 모순되는 오래된 텍스트를 남기지 마십시오.
    - 컨텍스트 손실 위험을 최소화하기 위해 각 통합 후에 사양 파일을 저장하십시오 (원자적 덮어쓰기).
    - 서식 유지: 관련 없는 섹션의 순서를 바꾸지 마십시오. 헤딩 계층 구조를 그대로 유지하십시오.
    - 삽입된 각 명확화 내용을 최소한으로 유지하고 테스트 가능하게 만드십시오 (서술적 드리프트 지양).

6. 검증 (각 쓰기 후 및 최종 패스 시 수행):
   - Clarifications 세션에 수락된 답변당 정확히 하나의 불렛이 포함되어 있는지 확인합니다 (중복 없음).
   - 총 질문(수락됨) 수 ≤ 5.
   - 업데이트된 섹션에 새로운 답변으로 해결하려 했던 모호한 자리 표시자가 남아 있지 않은지 확인합니다.
   - 모순되는 이전 진술이 남아 있지 않은지 확인합니다.
   - 마크다운 구조가 유효한지 확인합니다. 허용된 새 헤딩: `## Clarifications`, `### Session YYYY-MM-DD`.
   - 용어 일관성: 모든 업데이트된 섹션에서 동일한 표준 용어가 사용되었는지 확인합니다.

7. 업데이트된 사양을 `FEATURE_SPEC`에 다시 씁니다.

8. 완료 보고 (질문 루프 종료 또는 조기 종료 후):
   - 질문 및 답변 횟수
   - 업데이트된 사양 경로
   - 수정된 섹션 목록
   - 각 분류 카테고리에 대한 상태를 나열하는 커버리지 요약 표: 해결됨(Resolved, 부분적/누락이었으나 해결됨), 보류됨(Deferred, 질문 할당량을 초과했거나 계획 단계에 더 적합함), 명확(Clear, 이미 충분함), 미결(Outstanding, 여전히 부분적/누락이지만 영향도가 낮음).
   - 미결(Outstanding) 또는 보류(Deferred) 항목이 남은 경우, `/speckit.plan`으로 진행할지 아니면 나중에 계획 수립 후 `/speckit.clarify`를 다시 실행할지 권장 사항을 제시하십시오.
   - 제안하는 다음 명령.

동작 규칙:

- 의미 있는 모호성을 찾지 못한 경우(또는 모든 잠재적 질문의 영향도가 낮은 경우) 다음과 같이 응답하십시오: "공식적인 명확화가 필요한 중대한 모호성이 발견되지 않았습니다." 그리고 진행을 제안하십시오.
- 사양 파일이 누락된 경우 사용자에게 `/speckit.specify`를 먼저 실행하도록 안내하십시오 (여기서 새 사양을 생성하지 마십시오).
- 총 질문 수는 절대 5개를 초과하지 마십시오 (단일 질문에 대한 명확화 재시도는 새로운 질문으로 계산하지 않습니다).
- 부재가 기능적 명확성을 방해하지 않는 한 추측성 기술 스택 질문은 피하십시오.
- 사용자의 조기 종료 신호("중단", "완료", "진행")를 존중하십시오.
- 전체 커버리지로 인해 질문을 하지 않은 경우 요약된 커버리지 요약(모든 카테고리 명확)을 출력한 다음 진행을 제안하십시오.
- 해결되지 않은 고영향 카테고리가 있는 상태에서 할당량에 도달한 경우, 근거와 함께 보류됨(Deferred) 아래에 명시적으로 표시하십시오.

우선순위 결정을 위한 컨텍스트: {{args}}
"""
